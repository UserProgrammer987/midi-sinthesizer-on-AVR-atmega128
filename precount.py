#!/usr/bin/env python3
import math

# Настройте здесь:
SAMPLE_RATE = 15935.0    # <- поставьте ваш sample rate (например 16000, 44100, 48000)
A4_FREQ = 440.0          # эталон A4 (обычно 440.0)

# Вспомогательная функция: MIDI -> частота (Hz), равномерно темперированная шкала
def midi_to_freq(midi_note, a4_freq=A4_FREQ):
    return a4_freq * (2 ** ((midi_note - 69) / 12.0))

# Вычисление phase step: (freq * 2^32) / SAMPLE_RATE
DEF_2POW32 = 4294967296.0  # 2^32

phase_steps = []
midi_range = range(0, 101)  # включительно 20..100

for note in midi_range:
    freq = midi_to_freq(note)
    # Поведение как в C с (uint32_t) ( (freq * 2^32) / SAMPLE_RATE )
    val = int((freq * DEF_2POW32) / SAMPLE_RATE)
    # ограничение 32-бит unsigned (необязательно в Python, но для ясности)
    val &= 0xFFFFFFFF
    phase_steps.append(val)

# Печать C массива
print("/* Generated by script — SAMPLE_RATE = {}, A4_FREQ = {} */".format(int(SAMPLE_RATE), A4_FREQ))
print("static const uint32_t phase_step[] = {")
for i, v in enumerate(phase_steps):
    # красивый вывод по 8 значений в строке
    if i % 8 == 0:
        print("    ", end="")
    print(f"{v:10d}, ", end="")
    if i % 8 == 7:
        print()
# если последняя строка не завершилась переводом строки, добавим его
if len(phase_steps) % 8 != 0:
    print()
print("};\n")

# Вывод значения для ноты 69 (A4) для быстрой проверки
note_check = 69
freq69 = midi_to_freq(note_check)
val69 = int((freq69 * DEF_2POW32) / SAMPLE_RATE) & 0xFFFFFFFF
print(f"Note {note_check} (A4 = {A4_FREQ} Hz) -> freq = {freq69:.6f} Hz")
print(f"phase_step[{note_check}] = {val69}  (decimal), {val69:#010x} (hex), {val69:.6e} (scientific)")
