#include <avr/io.h>
#define F_CPU 11059200UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <stdio.h>

#define RS 5 // нога PE0(proteus)/PD5 к RS подключена
#define RW 4 // нога PE1(proteus)/PD4 к RW подключена
#define E 6 // нога PE2(proteus)/PD6 к E подключена

// =============================================
// Более компактный вариант (только нужный диапазон)
// =============================================

// Octave 0
#define AS0 10
#define B0  11

// Octave 1
#define C1  12
#define CS1 13
#define D1  14
#define DS1 15
#define E1  16
#define F1  17
#define FS1 18
#define G1  19
#define GS1 20
#define A1  21
#define AS1 22
#define B1  23

// Octave 2
#define C2  24
#define CS2 25
#define D2  26
#define DS2 27
#define E2  28
#define F2  29
#define FS2 30
#define G2  31
#define GS2 32
#define A2  33
#define AS2 34
#define B2  35

// Octave 3
#define C3  36
#define CS3 37
#define D3  38
#define DS3 39
#define E3  40
#define F3  41
#define FS3 42
#define G3  43
#define GS3 44
#define A3  45
#define AS3 46
#define B3  47

// Octave 4
#define C4  48
#define CS4 49
#define D4  50
#define DS4 51
#define E4  52
#define F4  53
#define FS4 54
#define G4  55
#define GS4 56
#define A4  57
#define AS4 58
#define B4  59

// Octave 5
#define C5  60  // Middle C
#define CS5 61
#define D5  62
#define DS5 63
#define E5  64
#define F5  65
#define FS5 66
#define G5  67
#define GS5 68
#define A5  69  // A4 = 440 Hz
#define AS5 70
#define B5  71

// Octave 6
#define C6  72
#define CS6 73
#define D6  74
#define DS6 75
#define E6  76
#define F6  77
#define FS6 78
#define G6  79
#define GS6 80
#define A6  81
#define AS6 82
#define B6  83

// Octave 7
#define C7  84
#define CS7 85
#define D7  86
#define DS7 87
#define E7  88
#define F7  89
#define FS7 90
#define G7  91
#define GS7 92
#define A7  93
#define AS7 94
#define B7  95

// Octave 8
#define C8  96
#define CS8 97
#define D8  98
#define DS8 99
#define E8  100  // Ваш конечный диапазон

#define ZADERSHKA 125

uint16_t timeMs = 0;

void setTimeZero(){
    TCNT1 = 0;
    timeMs = 0;
}

uint16_t getTimeMs(){
    return timeMs;
}

const uint8_t sine[1024] = {
    127, 128, 129, 129, 130, 131, 132, 132, 133, 134, 135, 136, 136, 137, 138, 139,
    139, 140, 141, 142, 143, 143, 144, 145, 146, 146, 147, 148, 149, 150, 150, 151,
    152, 153, 153, 154, 155, 156, 156, 157, 158, 159, 159, 160, 161, 162, 163, 163,
    164, 165, 166, 166, 167, 168, 168, 169, 170, 171, 171, 172, 173, 174, 174, 175,
    176, 177, 177, 178, 179, 179, 180, 181, 182, 182, 183, 184, 184, 185, 186, 186,
    187, 188, 188, 189, 190, 191, 191, 192, 193, 193, 194, 195, 195, 196, 197, 197,
    198, 198, 199, 200, 200, 201, 202, 202, 203, 204, 204, 205, 205, 206, 207, 207,
    208, 208, 209, 210, 210, 211, 211, 212, 213, 213, 214, 214, 215, 215, 216, 217,
    217, 218, 218, 219, 219, 220, 220, 221, 221, 222, 223, 223, 224, 224, 225, 225,
    226, 226, 227, 227, 228, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233,
    233, 233, 234, 234, 235, 235, 236, 236, 236, 237, 237, 238, 238, 238, 239, 239,
    239, 240, 240, 241, 241, 241, 242, 242, 242, 243, 243, 243, 244, 244, 244, 244,
    245, 245, 245, 246, 246, 246, 247, 247, 247, 247, 248, 248, 248, 248, 249, 249,
    249, 249, 249, 250, 250, 250, 250, 250, 251, 251, 251, 251, 251, 252, 252, 252,
    252, 252, 252, 252, 253, 253, 253, 253, 253, 253, 253, 253, 254, 254, 254, 254,
    254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254,
    255, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254, 254,
    254, 254, 254, 254, 254, 253, 253, 253, 253, 253, 253, 253, 253, 252, 252, 252,
    252, 252, 252, 252, 251, 251, 251, 251, 251, 250, 250, 250, 250, 250, 249, 249,
    249, 249, 249, 248, 248, 248, 248, 247, 247, 247, 247, 246, 246, 246, 245, 245,
    245, 244, 244, 244, 244, 243, 243, 243, 242, 242, 242, 241, 241, 241, 240, 240,
    239, 239, 239, 238, 238, 238, 237, 237, 236, 236, 236, 235, 235, 234, 234, 233,
    233, 233, 232, 232, 231, 231, 230, 230, 229, 229, 228, 228, 228, 227, 227, 226,
    226, 225, 225, 224, 224, 223, 223, 222, 221, 221, 220, 220, 219, 219, 218, 218,
    217, 217, 216, 215, 215, 214, 214, 213, 213, 212, 211, 211, 210, 210, 209, 208,
    208, 207, 207, 206, 205, 205, 204, 204, 203, 202, 202, 201, 200, 200, 199, 198,
    198, 197, 197, 196, 195, 195, 194, 193, 193, 192, 191, 191, 190, 189, 188, 188,
    187, 186, 186, 185, 184, 184, 183, 182, 182, 181, 180, 179, 179, 178, 177, 177,
    176, 175, 174, 174, 173, 172, 171, 171, 170, 169, 168, 168, 167, 166, 166, 165,
    164, 163, 163, 162, 161, 160, 159, 159, 158, 157, 156, 156, 155, 154, 153, 153,
    152, 151, 150, 150, 149, 148, 147, 146, 146, 145, 144, 143, 143, 142, 141, 140,
    139, 139, 138, 137, 136, 136, 135, 134, 133, 132, 132, 131, 130, 129, 129, 128,
    127, 126, 125, 125, 124, 123, 122, 122, 121, 120, 119, 118, 118, 117, 116, 115,
    115, 114, 113, 112, 111, 111, 110, 109, 108, 108, 107, 106, 105, 104, 104, 103,
    102, 101, 101, 100,  99,  98,  98,  97,  96,  95,  95,  94,  93,  92,  91,  91,
     90,  89,  88,  88,  87,  86,  86,  85,  84,  83,  83,  82,  81,  80,  80,  79,
     78,  77,  77,  76,  75,  75,  74,  73,  72,  72,  71,  70,  70,  69,  68,  68,
     67,  66,  66,  65,  64,  63,  63,  62,  61,  61,  60,  59,  59,  58,  57,  57,
     56,  56,  55,  54,  54,  53,  52,  52,  51,  50,  50,  49,  49,  48,  47,  47,
     46,  46,  45,  44,  44,  43,  43,  42,  41,  41,  40,  40,  39,  39,  38,  37,
     37,  36,  36,  35,  35,  34,  34,  33,  33,  32,  31,  31,  30,  30,  29,  29,
     28,  28,  27,  27,  26,  26,  26,  25,  25,  24,  24,  23,  23,  22,  22,  21,
     21,  21,  20,  20,  19,  19,  18,  18,  18,  17,  17,  16,  16,  16,  15,  15,
     15,  14,  14,  13,  13,  13,  12,  12,  12,  11,  11,  11,  10,  10,  10,  10,
      9,   9,   9,   8,   8,   8,   7,   7,   7,   7,   6,   6,   6,   6,   5,   5,
      5,   5,   5,   4,   4,   4,   4,   4,   3,   3,   3,   3,   3,   2,   2,   2,
      2,   2,   2,   2,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,
      2,   2,   2,   2,   3,   3,   3,   3,   3,   4,   4,   4,   4,   4,   5,   5,
      5,   5,   5,   6,   6,   6,   6,   7,   7,   7,   7,   8,   8,   8,   9,   9,
      9,  10,  10,  10,  10,  11,  11,  11,  12,  12,  12,  13,  13,  13,  14,  14,
     15,  15,  15,  16,  16,  16,  17,  17,  18,  18,  18,  19,  19,  20,  20,  21,
     21,  21,  22,  22,  23,  23,  24,  24,  25,  25,  26,  26,  26,  27,  27,  28,
     28,  29,  29,  30,  30,  31,  31,  32,  33,  33,  34,  34,  35,  35,  36,  36,
     37,  37,  38,  39,  39,  40,  40,  41,  41,  42,  43,  43,  44,  44,  45,  46,
     46,  47,  47,  48,  49,  49,  50,  50,  51,  52,  52,  53,  54,  54,  55,  56,
     56,  57,  57,  58,  59,  59,  60,  61,  61,  62,  63,  63,  64,  65,  66,  66,
     67,  68,  68,  69,  70,  70,  71,  72,  72,  73,  74,  75,  75,  76,  77,  77,
     78,  79,  80,  80,  81,  82,  83,  83,  84,  85,  86,  86,  87,  88,  88,  89,
     90,  91,  91,  92,  93,  94,  95,  95,  96,  97,  98,  98,  99, 100, 101, 101,
    102, 103, 104, 104, 105, 106, 107, 108, 108, 109, 110, 111, 111, 112, 113, 114,
    115, 115, 116, 117, 118, 118, 119, 120, 121, 122, 122, 123, 124, 125, 125, 126,
};

#define TABLE_SIZE 1024
#define TABLE_BITS 10
#define SAMPLE_RATE 15935

static const uint32_t phase_step[101] = {
       2203626,    2334660,    2473487,    2620568,    2776395,    2941488,    3116398,    3301709,
       3498039,    3706043,    3926416,    4159892,    4407253,    4669321,    4946974,    5241136,
       5552790,    5882977,    6232797,    6603418,    6996078,    7412086,    7852832,    8319785,
       8814506,    9338643,    9893948,   10482273,   11105581,   11765954,   12465594,   13206836,
      13992156,   14824173,   15705664,   16639571,   17629012,   18677287,   19787897,   20964546,
      22211163,   23531908,   24931188,   26413673,   27984312,   29648346,   31411328,   33279143,
      35258024,   37354575,   39575794,   41929093,   44422327,   47063816,   49862376,   52827347,
      55968625,   59296693,   62822657,   66558287,   70516049,   74709151,   79151589,   83858187,
      88844654,   94127633,   99724753,  105654695,  111937250,  118593386,  125645315,  133116575,
     141032098,  149418303,  158303178,  167716375,  177689309,  188255266,  199449506,  211309391,
     223874501,  237186772,  251290631,  266233150,  282064197,  298836607,  316606356,  335432750,
     355378619,  376510532,  398899013,  422618783,  447749003,  474373545,  502581263,  532466301,
     564128394,  597673214,  633212713,  670865501,  710757239,
};

static uint32_t phase[101] = {0};

void init_phase_accumulators(void){
    for (uint8_t i = 0; i<101; i++){
        phase[i] = 0;
    }
}

void allPhaseNullify(void){
    for (uint8_t i = 0; i<101; i++){
        phase[i] = 0;
    }
}

uint8_t get_amplitude_note(uint8_t note)
{   
    if (note == 0){
        return 0;
    }

    phase[note] += phase_step[note]; return sine[phase[note] >> 22];
}


typedef struct {
    uint8_t note;
    uint16_t event_settings; //старший бит(15й) - 0 или 1, включить или выключить ноту
    // биты после него(с 14-го по 12й) - на какой канал включить ноту
    // оставшиеся биты - на каком step событие должно совершиться

} event;

typedef struct {
    uint8_t note;
    uint8_t amp;
} channel;

channel channels[] = { 
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
    {0, 0},
};

void channel_amplitude_set(uint8_t channel_num){
    uint8_t ampl; 
    ampl = get_amplitude_note(channels[channel_num].note);
    channels[channel_num].amp = ampl;
}

// D:/Study/5sem/MPU SU/st7920/Megalovania.mid
static event megalovania[] =
{
    {D4, 32768}, {D4, 2}, {D4, 32770}, {D4, 4}, {D5, 32772}, {D5, 8}, {A4, 32776}, {A4, 15}, {GS4, 32783}, {GS4, 19}, {G4, 32787}, {G4, 23}, {F4, 32791}, {F4, 28}, {D4, 32796}, {D4, 30}, {F4, 32798}, {F4, 32}, {G4, 32800}, {G4, 34}, {C4, 32802}, {C4, 36}, {C4, 32804}, {C4, 38}, {D5, 32807}, {D5, 43}, {A4, 32811}, {A4, 49}, {GS4, 32817}, {GS4, 54}, {G4, 32822}, {G4, 58}, {F4, 32826}, {F4, 62}, {D4, 32830}, {D4, 65}, {F4, 32833}, {F4, 67}, {G4, 32835}, {G4, 69}, {B3, 32837}, {B3, 71}, {B3, 32839}, {B3, 73}, {D5, 32841}, {D5, 78}, {A4, 32846}, {A4, 84},
};
uint16_t music_counter = 0; //счётчик нот
uint16_t counter_of_events = ( sizeof(megalovania) / sizeof(event) ); //счётчик количества событий в песне

#define bpm 230
static uint16_t ms_for_1beat = (60000.3f / bpm); //миллисекунд за бит
uint16_t dlit_ms[];

uint64_t global_event_counter = 0;
uint64_t global_tick_counter = 0;

void do_events(event song[], uint64_t event_counter){
    uint8_t note = song[event_counter].note; //нота
    uint8_t num = ( (song[event_counter].event_settings) >> 12 ) & 0b111; //номер канала (сначала сдвинули на 12 вправо, чтобы убрать все младшие биты, а затем маску чтобы убрать старшие биты)
    uint8_t switch_code = ( (song[event_counter].event_settings) >> 15 ) & 1; //действие включить/выключить
    uint64_t tick = (song[event_counter].event_settings & 0xFFF) * 952; // на каком тике должно быть событие, 952-перевод из "шага" в тик прерывания
    if (tick <= global_tick_counter){

        if (switch_code){
            channels[num].note = note;
        }
        else{
            channels[num].note = 0;
        }
    }
    else{
        return;
    }

    global_event_counter++;
    if (global_event_counter > counter_of_events){
        global_event_counter = 0;
        global_tick_counter = 0;
    }
   
}

// доделать release factor
uint8_t release_factor(void){

}

bool is_active(uint8_t number){
    if (number != 0){
        return 1;
    }
    else{
        return 0;
    }
}

void duty_set(void) {
    uint8_t duty;
    //uint8_t number_of_active_channels = 0;


    //number_of_active_channels = is_active(channels[0].note) + is_active(channels[1].note) + is_active(channels[2].note) + is_active(channels[3].note) + is_active(channels[4].note) + is_active(channels[5].note) + is_active(channels[6].note) + is_active(channels[7].note);


    duty = (channels[0].amp + channels[1].amp) >> 1;

    OCR0 = ( duty );
}




int main(void)
{
    init_phase_accumulators();

    DDRF = 0xFF;

    DDRB = 0xFF;

    TCCR1B = (1 << WGM12) | (1 << CS10); // 11059200/(1+11058) = 1000гц, считает миллисекунды
    OCR1A = 11058;
    TIMSK = (1 << OCIE1A); //прерывание добавляет счётчику миллисекунд 1

    TCCR0 = (1 << CS00) | (1 << COM01) | (1 << WGM01) | (1 << WGM00); // 0-таймер для ШИМ
    // 8-бит ШИМ, нет предделителя(1 в CS00), частота 11052900/256 = 43175 (в proteus измерил, проверил)

    TCCR3B = (1 << WGM32) | (1 << CS30); // 3-таймер для частоты дискретизации музыки, CTC-режим и 1-предделитель
    OCR3A = 690; // считает с частотой 11059200(частота МК)/( 1(предделитель) * (1+690(OCR3A-граница счёта)) = 15935 Гц, наша частота дискретизации
    ETIMSK = (1 << OCIE3A); //прерывание у 3-го таймера по переполнению(которое происходит 15935 раз в секунду) или раз в 63 мкс
    sei();

    while (1) 
    {   
        
    }
}


ISR(TIMER3_COMPA_vect){
    do_events(megalovania, global_event_counter);
    channel_amplitude_set(0);
    channel_amplitude_set(1);

    duty_set();

    global_tick_counter++;
}

ISR(TIMER1_COMPA_vect){
    timeMs++;
}